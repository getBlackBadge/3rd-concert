# 동시성 이슈와 제어 방식에 대한 분석

## 1. 시나리오에서 발생할 수 있는 동시성 이슈

1. **대기열 큐**: 여러 사용자가 동시에 예약을 시도할 경우, 동시성 이슈로 인해 중복된 순번이 부여될 위험이 있습니다.
2. **좌석 예약**: 동일한 좌석을 동시에 예약하려는 경우 중복 예약이 발생할 수 있습니다.
3. **포인트 사용**: 여러 사용자가 동시에 포인트를 사용하는 경우 중복 사용의 문제가 발생할 수 있습니다.

## 2. 동시성 제어 방식 비교

### DB 트랜잭션 락

#### 1. 낙관적 락
   - **설명**: 데이터가 수정될 때에만 버전을 기반으로 락을 사용하고, 읽기 작업에는 락을 걸지 않아 성능이 우수합니다. 다만, 수정 시 충돌이 발생할 가능성이 있으며, 충돌 시 별도의 처리가 필요해 사용자가 불편을 겪을 수 있습니다.
   - **구현 복잡도**: ★☆☆☆☆  
   - **성능**: ★★★★☆  
   - **효율성**: ★★★★★  

#### 2. 비관적 락
   - **설명**: 읽기와 수정 시 모두 락을 사용해 동시성 이슈를 방지할 수 있습니다. 그러나 모든 작업에 락을 걸기 때문에 성능 저하가 우려되며, 트래픽이 높은 환경에서는 부적합할 수 있습니다.
   - **구현 복잡도**: ★★★★☆  
   - **성능**: ★☆☆☆☆  
   - **효율성**: ★★★☆☆  

부연설명 : MSA 환경을 고려한다면 DB도 여러 인스턴스로 생성할 수도 있는데 이런 상황에서 DB의 트랜잭션에 의지한 lock은 문제가 될 수 있습니다.

### Redis 기반 분산 락

#### 1. Redis 기반 낙관적 락
   - **설명**: MSA 환경에서 데이터 일관성을 유지하기 어려우며, MSA환경에서 db 트랜잭션과 같이 쓸 이유가 없습니다.

#### 2. Redis 기반 분산 락 (no wait | wait)
   - **설명**: Redis를 사용해 락을 분산 처리하며, `sorted_set` 구조를 활용하여 순차적으로 락을 부여할 수 있어 MSA 환경에서 높은 성능과 효율성을 제공합니다. Redis 기반 락은 대량의 트래픽을 처리해야 하는 환경에서의 데이터 일관성을 보장할 수 있습니다. 자기 순서를 기다리는 락과 그냥 락을 획득하지 못하면 거절하는 락으로 상황에 맞게 구현할 수 있습니다.
   - **구현 복잡도**: ★★★★★  
   - **성능**: ★★★★★  
   - **효율성**: ★★★★★  

부연설명 : 트래픽이 높은 환경에서 db의 락 기능을 사용하지 않고 Redis의 락 기능을 사용한다면 데이터베이스에 대한 부하를 줄일 수 있는 장점이 있습니다. 또한 MSA환경에서 Redis cluster를 사용한다면 안정적으로 멀티 인스턴스 환경에서도 관리할 수 있습니다.

### 메시지 큐 (Kafka)

#### 1. Kafka 기반 메시지 큐
   - **설명**: Kafka는 메시지 큐를 통해 동시성을 효과적으로 제어하며, 요청을 순차적으로 처리하여 데이터 일관성을 보장합니다. 메시지 큐 방식은 대량의 트래픽을 분산하고 처리 순서를 보장해, 높은 동시성 요구 사항을 안정적으로 충족할 수 있습니다. 다만, 시스템 설계와 구현의 복잡도가 높아 프로젝트에서 추가 시간이 필요합니다.
   - **구현 복잡도**: ★★★★★  
   - **성능**: ★★★★★  
   - **효율성**: ★★★★★  

Kafka와 같은 메시지 큐를 활용하면 각 요청을 큐에 순차적으로 쌓고 처리하여 동시성 문제를 효과적으로 해결할 수 있습니다. 이는 특히 분산 환경에서 여러 인스턴스가 처리할 때 유리합니다 하지만 이러한 큐 기반 아키텍처는 설정과 운영이 복잡해, 제한된 시간 내에는 적용하기 어려울 수 있습니다.


## 결론
MSA환경도 고려하고 한정된 시간을 고려했을 때, redis를 활용한 분산락이 적합해보입니다. 성능도 준수하고 락 기능을 DB에서 분리하기 때문에 이미 부하가 큰 DB의 추가적인 부담을 줄일 수 있습니다.

기능별로 세부적으로 선정한 lock은 다음과 같습니다
1. **대기열 큐**:
- 선택: 순차성을 보장하는 Redis 분산락 
- 이유: 순간 100명의 요청이 오면 요청 순서대로 대기번호를 발급해야하므로 순차성을 보장해야합니다.
2. **좌석 예약**:
- 선택: 순차성을 보장하지 않는 no wait Redis 분산락 
- 이유: 좌석 예약 특성상, 재고는 항상 1입니다. 이미 락이 걸렸다면 그 다음 요청은 크게 의미가 없습니다. 기다리는 동작을 줄여 자원을 효율적으로 활용할 수 있습니다.
3. **포인트 사용**
- 선택: 순차성을 보장하는 Redis 분산락 
- 이유: 포인트 사용은 소비자로부터 재화를 사용하게 하는 중요한 동작입니다. 단순히 동시에 요청이 왔다는 이유만으로 돈 쓰는 요청을 거절한다면 회사의 대표가 가만히 있지 않을겁니다... 최대한 알뜰 살뜰 기다렸다가 잔고가 남아있다면 최대한 결제시키는 서비스가 더 합리적으로 보입니다. 따라서 순서를 기다렸다 결제를 시도하는 분산락으로 결정했습니다.