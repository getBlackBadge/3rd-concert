### STEP 20: 성능 지표 분석 및 개선

#### 1. **테스트 결과 분석**
- **지표**:
  - **요청 처리 시간**: 부하 테스트 시 평균 요청 시간 200~350ms로, 안정적인 성능을 보였으며, 스트레스 테스트에서도 응답 시간이 크게 증가하지 않았습니다.
  - **성공률**: 모든 테스트에서 100% 성공률을 기록하여, 시스템이 정상적으로 동작함을 확인할 수 있었습니다.
  - **데이터 전송량**: 요청 처리량에 비례한 데이터 송수신량이 발생했으며, 높은 동시 사용자 환경에서도 시스템이 정상적으로 처리할 수 있음을 확인했습니다.

- **결과**:
  - **부하 테스트**와 **내구성 테스트**에서 시스템은 평균 200ms 내외의 응답 시간을 기록했으며, **스트레스 테스트**와 **최고 부하 테스트**에서도 성능 저하 없이 안정적으로 동작했습니다.
  - 특히, **동시 조회 요청 처리**와 **대기열 요청 처리**에서 높은 동시 사용자 환경에서도 시스템이 원활하게 작동했으며, 트래픽이 몰려도 정상적으로 처리가 가능했음을 확인했습니다.

- **병목 탐색**
  - Redis는 대기열 시스템에서 병목 현상이 발생하지 않았습니다. 이는 Redis를 사용한 큐 방식 대신, **`incr`**를 사용하여 순서를 관리하고, 유량제어를 JWT 토큰에 저장하여 토큰 검증을 통해 입장 순서를 결정하는 방식이었기 때문입니다.
  - **DB**와 **애플리케이션**에서 병목 현상이 발생할 가능성이 있으므로, 향후 데이터베이스 쿼리 최적화와 애플리케이션 로직 개선이 필요합니다.
  - **네트워크**의 트래픽도 중요한 성능 지표로, 트래픽 과부하가 발생할 경우 **서버**나 **클라이언트** 측에서 유연한 대응이 필요할 수 있습니다.

- **개선 방안**
  - **데이터베이스 최적화**:
    - **쿼리 최적화**: 특정 쿼리가 느리거나 불필요하게 자원을 많이 사용하는 경우, 인덱스를 추가하거나 쿼리 구조를 개선하여 데이터베이스의 응답 시간을 단축할 수 있습니다.
    - **데이터베이스 연결 풀**: 연결 수가 과도하게 증가하면 DB 성능에 영향을 미칠 수 있으므로, 적절한 커넥션 풀링을 적용해 DB 성능을 개선할 수 있습니다.


  - **Redis 활용 개선**:
    - **Redis TTL 최적화**: 캐시된 데이터에 TTL을 설정하여 필요 없는 데이터가 계속해서 저장되지 않도록 하고, 만료된 데이터를 정리하는 방식으로 Redis의 성능을 최적화할 수 있습니다.
    - Redis 큐를 사용하지 않는 현재의 시스템에서는, Redis 자체 성능에 대한 부담이 적어 병목 현상이 크지 않으나, 추후 기능 확장에 따라 고려할 수 있는 부분입니다.
    - **Redis 분산락 최적화**: 분산 환경에서 Redis를 사용한 락 관리가 부하를 일으킬 수 있기 때문에, **Redis 클러스터링**을 고려하여 부하 분산 및 성능 향상을 도모할 수 있습니다. 클러스터링을 통해 여러 Redis 인스턴스를 연결하여 분산 락을 더 효율적으로 관리하고, 락이 필요한 작업이 과도하게 집중되지 않도록 할 수 있습니다. 클러스터링을 통해 고가용성 및 성능을 더욱 향상시킬 수 있습니다.

  - **애플리케이션 최적화**:
    - **동시성 처리 최적화**: 대기열 시스템에서 순서를 관리하는 부분에서 **`incr`**만을 사용하여 성능 저하를 방지하고 있으므로, 병렬 처리 및 효율적인 유량 제어 방식을 통해 더욱 안정적인 처리가 가능합니다.
    - **API 응답 시간 개선**: API 요청을 처리하는 로직에서 불필요한 지연을 줄일 수 있는 방법을 찾는 것이 중요합니다. 특히, 과도한 동기 처리나 불필요한 작업을 비동기 처리로 전환하여 성능을 개선할 수 있습니다.

#### 2. **장애 대응 문서**
- **대응 시나리오**:
  - **OOM 발생 시**: Redis TTL 설정 및 캐시 데이터 정리, 메모리 사용량이 일정 수준을 초과하지 않도록 조치합니다. 캐시된 데이터를 일정 시간마다 제거하거나, 캐시 크기를 제한하여 OOM 문제를 방지할 수 있습니다.
  - **트랜잭션 충돌 시**: 재시도 로직을 추가하여 트랜잭션이 실패했을 경우, 일정 횟수 이상 실패하지 않도록 하며, 실패한 트랜잭션에 대해 적절한 대기시간을 두고 재시도하는 방식으로 시스템 안정성을 확보합니다.
  - **과부하 발생 시**: 요청 제한(rate limiting)과 서킷 브레이커 패턴을 도입하여, 과도한 트래픽을 차단하고 시스템 과부하를 방지할 수 있습니다. 이를 통해 서비스의 안정성과 가용성을 유지할 수 있습니다.

이와 같이 성능 지표 분석을 통해 시스템의 성능을 높이고, 병목을 해결할 수 있는 방법들을 적용하면, 더욱 견고한 서비스가 될 것입니다.